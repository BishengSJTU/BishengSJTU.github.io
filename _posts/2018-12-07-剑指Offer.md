---
layout:     post
title:      剑指Offer
subtitle:   剑指Offer的一些思考过程
date:       2018-12-07
author:     Bisheng
header-img: img/post-bg-hacker.jpg
catalog: true
tags:
    - Data Structure
    - Offer
---

> “昨夜西风凋碧树。独上高楼，望尽天涯路。”
> 
> [我的博客](http://bishengsjtu.github.io)
>
> [github上上传了实现代码](https://github.com/BishengSJTU/JianZhiOffer)，
>
>是利用Clion这个IDE写的，Clion不论是代码风格还是调试都非常赞啦，强推！

# 1.二维数组中的查找
原题：
>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。
>请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

思路：
1. 暴力搜索每一个元素
2. 借鉴二分查找的思路，不断缩小搜索区间，
先按行二分查找，找到分界点后，将区间缩小一半量级（注：可能不是真正的一半），
再按列二分查找，找到同样找到分界点，减小区间。
直到找到元素返回true或区间矛盾返回false。
3. 将待查元素与区间右上角元素进行比较，一次减小一行或一列的范围（答案给出的思路）。

我觉得思路2的查找速度应该是比思路3快的，因为一次可以减小一半的搜索空间

本质：
搜索的过程其实就是想办法**不断减小搜索区间**的过程。利用递归可以简化思路，利用二分可以减小复杂度。

# 2.替换空格
原题：
>请实现一个函数，将一个字符串中的每个空格替换成“%20”。
>例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

思路：
1. 从前到后扫描，每次遇到空格就将后面所有的字符向后移动两格，填入%20
2. 先一次扫描字符串，得到空格数，同时将两个指针初始化——p1指向原字符串尾部，p2指向p1元素移动后出现的位置
再从后往前扫描，将每个字符串移动到它们应该出现的位置上

# 3.从尾到头打印链表
原题：
>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。

思路：
1. 非递归，遍历链表，将元素输进Vector中，最后打印
2. 递归，从尾到头打印就是每要打印一个元素，就要先打印以它下一个元素为头的链表，再打印它自己

# 4.重建二叉树
原题：
>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。
>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
>例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

思路：
1. 递归，在两个序列中找到根结点，将序列分成左子树和右子树，再递归重建左右子树

# 5.用两个栈实现队列
原题：
>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。

思路：
1. 队push:push栈1
队pop:栈2不空，pop栈2 栈2空，pop每一个栈1元素再push到栈2中，最后pop栈2顶元素


# 6.旋转数组的最小数字
原题：
>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 
>输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

思路：
1. 从前向后遍历，算法复杂度O(N)
2. 二分查找， 算法复杂度O(logN)，此处需要注意的是，
当Array[middle]=Array[end]时，并不能判断出最小值是在middle的左边还是右边，因为数组是按非减的顺序排列的，并非递增
所以此种情况时需要可以用从区间的前到后进行遍历
利用递归算法，取左边区间和右边区间的最小值，左边区间和右边区间要有所减小，否则递归将可能陷入死循环。

本质：
搜索的过程其实就是想办法**不断减小搜索区间**的过程。利用递归可以简化思路，利用二分可以减小复杂度。

# 7.斐波拉契数列
原题
>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。
>n<=39

思路：
1. 暴力递归：`F(n) = F(n-1) + F(n-2)`，导致溢出
2. 循环实现：
```
Fn = Fn-1 + Fn-2;
Fn-2 = Fn-1;
Fn-1 = Fn;
```

# 8.跳台阶
原题
>一只青蛙一次可以跳上1级台阶，也可以跳上2级。
>求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。


思路：
这种类型的题基本思路就是用递归实现。
递归有两种思路：
设跳到N阶有FN种方法
1. 考虑要第N台阶，只有两种情况：1.先跳到N-1阶，再跳1阶；2.先跳到N-2阶，再跳2阶 `FN=FN-1+FN-2`
2. 考虑第一步，第一步可以跳1阶，后面的N-1阶有FN-1种跳法；第一步跳2阶，后面的N-2阶有FN-2种跳法，`FN=FN-1+FN-2`

两种想法异曲同工。
但是我们再真正编写代码时，并不需要写成递归形式，因为太占据内存，可以像解决问题7一样写成循环的形式。
这道问题就是一个斐波那契数列题。

# 9.变态跳台阶
原题
>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。
>求该青蛙跳上一个n级的台阶总共有多少种跳法。

思路：
与问题8类似，递推公式：`FN=FN-1+FN-2+...+F1+1`
主要问题在怎么将递归转化为循环上，我们可以看到，计算FN，就是将前面的所有项求和再加1，
同时我们也应当注意到，一旦FN求出来以后，求FN+1需要的前N项和也就可以更新了，不需要将前N项和再次一一加和，只需要在前N-1项和上加上FN即可
所以我们可以将前N项和在程序中记录下来，循环求解即可。

# 10.矩形覆盖
原题:
>我们可以用2×1的小矩形横着或者竖着去覆盖更大的矩形。
>请问用n个2×1的小矩形无重叠地覆盖一个2×n的大矩形，总共有多少种方法？

思路：
也是明显的递归思路，找规律。记n=N时共有FN种方法，那么FN与前面哪些项直接相关呢，就是FN-1和FN-2。
我们可以发现从FN-2可以有两种方法到达FN，FN-1只有一种方法可以到达FN，那么是不是FN=2×FN-2+FN-1呢，当然不是。
因为FN-2其中一种方法是要先到达FN-1再到FN，所以这部分被重复计算了，所以FN=2×FN-2+FN-1-FN-2=FN-2+FN-1，又是一个F数列

# 12.数值的整数次方
原题：
>给定一个double类型的浮点数base和int类型的整数exponent。
>求base的exponent次方。

思路：
考察代码的完备性，考虑各种情况。例如，底数为0.0时、指数小于0时该怎么处理。
还有，在计算指数次幂时，可以进行加速：base^(exp)=[base(exp/2)]^2
在加速过程中涉及到除以2和判断奇偶数的操作，利用**位操作代替乘除法和求余操作**可以再次加速。

# 38.二叉树的深度
原题：
>输入一棵二叉树，求该树的深度。
>从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。

思路：
1. 递归，每一棵树的深度就是它max（左子树的深度，右子树深度）+1
2. 非递归，利用某种遍历求树的深度