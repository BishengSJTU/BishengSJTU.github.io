---
layout:     post
title:      剑指Offer
subtitle:   剑指Offer的一些思考过程
date:       2018-12-07
author:     Bisheng
header-img: img/post-bg-hacker.jpg
catalog: true
tags:
    - Data Structure
    - Offer
---

> “昨夜西风凋碧树。独上高楼，望尽天涯路。”
>
> [github上上传了实现代码](https://github.com/BishengSJTU/JianZhiOffer)，
>
>是利用Clion这个IDE写的，Clion不论是代码风格还是调试都非常赞啦，强推！

# 1.二维数组中的查找
原题：
>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。
>请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

思路：
1. 暴力搜索每一个元素
2. 借鉴二分查找的思路，不断缩小搜索区间，
先按行二分查找，找到分界点后，将区间缩小一半量级（注：可能不是真正的一半），
再按列二分查找，找到同样找到分界点，减小区间。
直到找到元素返回true或区间矛盾返回false。
3. 将待查元素与区间右上角元素进行比较，一次减小一行或一列的范围（答案给出的思路）。

我觉得思路2的查找速度应该是比思路3快的，因为一次可以减小一半的搜索空间

本质：
搜索的过程其实就是想办法**不断减小搜索区间**的过程。利用递归可以简化思路，利用二分可以减小复杂度。

# 2.替换空格
原题：
>请实现一个函数，将一个字符串中的每个空格替换成“%20”。
>例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

思路：
1. 从前到后扫描，每次遇到空格就将后面所有的字符向后移动两格，填入%20
2. 先一次扫描字符串，得到空格数，同时将两个指针初始化——p1指向原字符串尾部，p2指向p1元素移动后出现的位置
再从后往前扫描，将每个字符串移动到它们应该出现的位置上

# 3.从尾到头打印链表
原题：
>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。

思路：
1. 非递归，遍历链表，将元素输进Vector中，最后打印
2. 递归，从尾到头打印就是每要打印一个元素，就要先打印以它下一个元素为头的链表，再打印它自己

# 4.重建二叉树
原题：
>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。
>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
>例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

思路：
1. 递归，在两个序列中找到根结点，将序列分成左子树和右子树，再递归重建左右子树

# 5.用两个栈实现队列
原题：
>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。

思路：
1. 队push:push栈1
队pop:栈2不空，pop栈2 栈2空，pop每一个栈1元素再push到栈2中，最后pop栈2顶元素


# 6.旋转数组的最小数字
原题：
>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 
>输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

思路：
1. 从前向后遍历，算法复杂度O(N)
2. 二分查找， 算法复杂度O(logN)，此处需要注意的是，
当Array[middle]=Array[end]时，并不能判断出最小值是在middle的左边还是右边，因为数组是按非减的顺序排列的，并非递增
所以此种情况时需要可以用从区间的前到后进行遍历
利用递归算法，取左边区间和右边区间的最小值，左边区间和右边区间要有所减小，否则递归将可能陷入死循环。

本质：
搜索的过程其实就是想办法**不断减小搜索区间**的过程。利用递归可以简化思路，利用二分可以减小复杂度。

# 7.斐波拉契数列
原题
>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。
>n<=39

思路：
1. 暴力递归：`F(n) = F(n-1) + F(n-2)`，导致溢出
2. 循环实现：
```
Fn = Fn-1 + Fn-2;
Fn-2 = Fn-1;
Fn-1 = Fn;
```

# 8.跳台阶
原题
>一只青蛙一次可以跳上1级台阶，也可以跳上2级。
>求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。


思路：
这种类型的题基本思路就是用递归实现。
递归有两种思路：
设跳到N阶有FN种方法
1. 考虑要第N台阶，只有两种情况：1.先跳到N-1阶，再跳1阶；2.先跳到N-2阶，再跳2阶 `FN=FN-1+FN-2`
2. 考虑第一步，第一步可以跳1阶，后面的N-1阶有FN-1种跳法；第一步跳2阶，后面的N-2阶有FN-2种跳法，`FN=FN-1+FN-2`

两种想法异曲同工。
但是我们再真正编写代码时，并不需要写成递归形式，因为太占据内存，可以像解决问题7一样写成循环的形式。
这道问题就是一个斐波那契数列题。

# 9.变态跳台阶
原题
>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。
>求该青蛙跳上一个n级的台阶总共有多少种跳法。

思路：
与问题8类似，递推公式：`FN=FN-1+FN-2+...+F1+1`
主要问题在怎么将递归转化为循环上，我们可以看到，计算FN，就是将前面的所有项求和再加1，
同时我们也应当注意到，一旦FN求出来以后，求FN+1需要的前N项和也就可以更新了，不需要将前N项和再次一一加和，只需要在前N-1项和上加上FN即可
所以我们可以将前N项和在程序中记录下来，循环求解即可。

# 10.矩形覆盖
原题:
>我们可以用2×1的小矩形横着或者竖着去覆盖更大的矩形。
>请问用n个2×1的小矩形无重叠地覆盖一个2×n的大矩形，总共有多少种方法？

思路：
也是明显的递归思路，找规律。记n=N时共有FN种方法，那么FN与前面哪些项直接相关呢，就是FN-1和FN-2。
我们可以发现从FN-2可以有两种方法到达FN，FN-1只有一种方法可以到达FN，那么是不是FN=2×FN-2+FN-1呢，当然不是。
因为FN-2其中一种方法是要先到达FN-1再到FN，所以这部分被重复计算了，所以FN=2×FN-2+FN-1-FN-2=FN-2+FN-1，又是一个F数列

# 12.数值的整数次方
原题：
>给定一个double类型的浮点数base和int类型的整数exponent。
>求base的exponent次方。

思路：
考察代码的完备性，考虑各种情况。例如，底数为0.0时、指数小于0时该怎么处理。
还有，在计算指数次幂时，可以进行加速：base^(exp)=[base(exp/2)]^2
在加速过程中涉及到除以2和判断奇偶数的操作，利用**位操作代替乘除法和求余操作**可以再次加速。

# 13.调整数组顺序使奇数位于偶数前面
原题：
>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，
>使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，
>并保证奇数和奇数，偶数和偶数之间的相对位置不变。

## 不要求相对位置保持不变
思路：
设置两个指针，p1指向数组头部，p2指向数组尾部，若发现p1指向偶数，p2指向奇数，则交换两个数。如此循环，直到p1与p2相遇

## 要求相对位置保持不变
思路：
1. 类似于插入排序或冒泡排序（因为它们是稳定的），奇数看作1，偶数看作2，复杂度$$O(N^2)$$
2. 用空间换取时间，另外开数组空间，两次遍历

# 14.链表中倒数第k个结点
原题：
>输入一个链表，输出该链表中倒数第k个结点。

思路：
1. 遍历两次
2. 利用两个指针，让它们相差k，其中一个指针指向NULL时，前面的指针指向的就是倒数第k个元素**链表中有时利用两个指针完成一些任务可能会大大简化时间和空间复杂度**

# 15.反转链表
原题：
>输入一个链表，反转链表后，输出新链表的表头。

思路：
1. 设置两个指针，一个指针指向已反转部分的头指针，另一个指向未反转部分的头部。不断循环即可。

# 16.合并两个排序的链表
原题：
>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。

思路：
1. 不断比较两个指针指向的数据的值，将小值放入合并链表中，更新链表指向

# \*17.树的子结构
原题：
>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）

思路：
1. 又是树的操作，让我们想到用递归的操作。现在定义另一种强子树结构：B的根与A的根相等，B的左子树不空的话，是A的左子树的强子树；B的右子树不空的话，是A的右子树的强子树
现在判断原题中的子树结构：1.当B与A的根都不空时，判断B是不是A的强子树；2.若B不是A的强子树：2-1判断B是不是A左子树的子树；2-2判断B是不是A右子树的子树。

# 18.合并两个排序的链表
原题：
>操作给定的二叉树，将其变换为源二叉树的镜像。

思路：
1. 树的题首先想想能不能用递归做（树本身的定义就是一种递归定义）。这道题可以用递归做，将一棵树镜像，就是交换它的根节点的两个指针指向，然后递归镜像左子树和右子树
2. 既然可以用递归做，就看看可不可以用循环实现。层序遍历（队列实现），三种深度遍历（堆栈实现）都可以完成镜像过程。只要在遍历到时交换左右子节点即可。

# 19.顺时针打印矩阵
原题：
>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，
>例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 
>则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.

思路：
循环可以解决的问题，关键就是判断好循环的起始和终止点以及循环结束的条件，可以设置四个变量：startRow,endRow,startCol,endCol，再按顺时针的规则进行循环即可。

# \*20.包含min函数的栈
原题：
>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。

思路：
维护两个栈，其中数据栈放数据，辅助栈放当前栈中最小元素。
如果数据栈push元素小于数据栈中最小元，那么辅助栈push此元素；
如果数据栈push元素大于等于数据栈中最小元素，那么辅助栈push进最小元，也就是当前辅助栈栈顶元素。

# \*21.栈的压入、弹出序列
原题：
>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。
>假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，
>但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）

思路：
利用两个指针和一个堆栈实现，指针i指向popV头，指针j指向pushV头。while(栈空||栈顶元素不等于i指向元素)，将j指向元素不断压入堆栈中。否则pop出栈顶元素，i++。
j如果溢出超过pushV范围，那么不断pop出栈中元素与popV中元素比较，一旦不相等则返回false。如果一直相等，最终返回true。

# 22.从上往下打印二叉树
原题：
>从上往下打印出二叉树的每个节点，同层节点从左至右打印。

思路：层序遍历，用队列实现。

# 23.二叉搜索树的后序遍历序列
原题：
>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。
>如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。

思路：二叉搜索树也是一个递归的定义，所以首先想到递归算法，后序遍历，那么最后的元素就是根节点，根据根节点将前面序列分为左子树和右子树。
如果①左子树所有元素小于根节点元素，右子树所有元素大于根节点元素，并且
②左子树（存在的话）是二叉搜索树序列，右子树（存在的话）也是一棵二叉搜索树序列，那么整个序列就是一个二叉搜索树的序列

# 24.二叉树中和为某一值的路径
原题：
>输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。
>路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。
>(注意: 在返回值的list中，数组长度大的数组靠前)

思路：找到所有的符合条件的路径，那么必须要将所有树中元素都看一遍，即需要进行一次遍历方可。
1. 可以用递归的方法
2. 我们想到遍历其实还可以用非递归实现，
这时在栈中的元素的总和就是从根到目前元素为止所有元素的总和（但是必须是后序遍历），
只需要判断当前节点是不是叶子结点以及到目前结点的和等不等与目标值即可。我在github中24题也实现了
**二叉树后序遍历的非递归实现**，只需要新增加一个变量last即可。

# 38.二叉树的深度
原题：
>输入一棵二叉树，求该树的深度。
>从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。

思路：
1. 递归，每一棵树的深度就是它max（左子树的深度，右子树深度）+1
2. 非递归，利用某种遍历求树的深度